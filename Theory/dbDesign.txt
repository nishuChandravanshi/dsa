
many To One -> foreignKey
************

user->register->emaidId(username)->pwd
login->check

User{
    emaildId charfield;
    password charfield;(*hash stored)
    //user details-->
}

User{
    emaildId charfield;
    password charfield;(*hash stored)
    //user details-->

    //multiple users (eg student, teachers,admin etc) 
    userType choiceField;
}
//for multiple users -> can make different tables and pass User as a ONE TO ONE key

Student{
    User oneToOne; (1student<->1user)
}


//LIBRARY MANAGEMENT

func-> 
//library->listOfBooks, lateFeesPerDay, duration,  
//for transaction-->
//issuedBook->bookId,studentId, issuedDate

// student->authentication, issuedBookId,lateFees: 
//book->details (bookId, availableNoOfCopies, totalNoOfCopies), library(foreign key)

Library{
    name charfield;
    //listOfBooks oneToMany; //oneToMany doesn't exist=> 1:n(-foreignKey)
    //oneToMany not possible=> manyToOne --> foreignKey in other table
    lateFeesPerDay float;
    duration integer;
}
IssuedBook{
    bookId foreignKey book;
    studentId foreignKey student;
    library foreignKey Library; //automatic id of Library table instance(row)
    issuedDate dateTimeField;
}

Student{
    rollNo charfield;
    issuedBookId foreignKey issuedBook; --> ?-> to get list of students who issued books
    lateFees float;    
}

Book{
    name charfield;
    bookSerialNumber charfield;
    availableNoOfCopies integer;
    totalNoOfCopies integer;
    library foreignKey Library;
}
       

//return list of issuedDate of Books in library named A

SELECT I.issuedDate FROM IssuedBook I
JOIN Library L ON I.library = L.pk (primary key) 
WHERE L.name LIKE 'A';

//return list of bookNames of issuedBooks in library named A

SELECT B.name FROM Books B
JOIN IssuedBook I ON I.bookId = B.pk
WHERE I.bookId EXIST IN (
    SELECT I.bookId FROM IssuedBook I
    JOIN Library L ON I.library = L.pk (primary key) 
    WHERE L.name LIKE 'A';
)

//
//SQL Queries

Table -> Employees

Bank: BNo, Name
Branch: BrNo, Name, BNo
Customer: CNo, Branch, Deposit, Name, Borrow

Bank {
    BNo : pK
    Name: char
}
Branch {
    BrNo: pK
    Name: char
    BankNo: fkey Bank
}
Customer {
    CNo: pK
    Branch: fkey Branch
    Deposit: float
    Borrow: float
    name: char
}
i)Print name of all customers of "Axis Bank"

T : Customer C join Branch Br on C.brno = Br.brno

T1 : Customer C join Branch Br on C.brno = Br.brno join Bank B on Br.BankNo = B.BankNo

Select C.Cname 
from 
    Customer C join Branch Br 
    on C.brno = Br.brno 
    join Bank B 
    on Br.BankNo = B.BankNo
    where B.BName like "Axis";

Select C.name from Customer C join Branch B 
on C.Branch = B.BrNo
where B.BankNo in (
    Select Bank.BNo from Branch join Bank 
    on Bank.BankNo = Branch.BankNo
    where Bank.name like "Axis Bank";
);

ii) Branch Names of all Axis Bank brnaches

a) Identify jojn
Table T -> Bank B inner join Branch Br on B.BankNo = Br.BankNo

b) Right query considering we have a Table(T) with all details after join
Select Brname from T
where name like "Axis";

c) Replace T:

Select Br.Brname from Bank B join Branch Br
on B.BankNo = Br.BankNo
where B.name like "Axis";

iii) 
Select Distinct(Br.Brname)
from
    Customer C join Branch Br
    on
        C.brno = Br.brno
    where c.Deposit =0;

***********************************************************************************************
1. KRISHI JAGARAN

//Krishi Jagaran basic db Design

Farmer->register-> login-> grainEntry-> customerRequestCheck->sell
Customer-> register->login-> listOfGrain ->order 

#entities->User, Grain
#transaction-> grainEntryDetail, orderDetails 

/*
User{
    emaildId charfield;
    pwd charfield;
    userRole choiceField;
}
--> farmer and customer details stored in same User table->
problems->
    -in orderDetails Farmer & customer both are foreignKey if common table is maintaind for both then there'll be trouble differentiating customer and farmer
sol-> specialization-> Farmer & User diff tables
*/

User{
    emaildId charfield;
    pwd charfield;
}

Farmer{
    user oneToOne User;
   // farm foreignKey Farm;    ->wrong as it=> many Farmer->1Farm 
}

Farm{
    location charfield;  //locatin in itself can be entity
    farmer foreignKey Farmer;
}

Customer{
    user oneToOne User;
}

Grain{
    name charfield;
    //life span, avg-price;
}

grainEntryDetail{
    grain foreignKey Grain;
    farmer foreignKey Farmer;
    quantity float;
    price float;
    quality charfield;
}

orderDetails{
    aprove bool;
    customer foreignKey Customer;
    farmer foreignKey Farmer;
    grain foreignKey Grain;
    quantity float;
    price float;
}

*****

##to do --
    -python libraries ie files,packages used(read definitions of those which has been used in ur project)
    -api(definition,which api and how), get post diff etc
    -topology types and definition

    -how does ur project work benefit xyz company?
    
#System Design
    -gfg instagram rt le

*****


//Krishi Jagaran DB design

Features
    -a common platform where different farmers can report their produce and sell 
    -considering the fact that not many farmers use smartphones, our app is seamlessly integrated with message services
        -particular format of msg eg
             to report produce->  REPORT<type><quantity><price>
             to store in warehouse-> STORE<type><quantity>       
    -smart warehouse management, after produce is reported we provide optimal list of warehouse and Delivery services
    
    -Since we have all the transaction data for a region in the centre we can do following things with it->
    i) Surplus deficit ...
        #note: there's only one server, and multiple virtual centers
        -we can ensures equitable distribution of food resources across differetn regions,
        like if theres  shortage of any particular food grain in region A then the server will send request msg to all other regions
        and then region with surplus of that particulr food grain can connect with region A and perform the required trade
    ii) Hoarding detection -> we have storage date
    iii) Since we now lifespan of a grain and its produce date we can inform the farmer before a threshold(let's say 60 days of perishing) 
    and also send the list of buyers who buy that grain frequently

    #avg lifespan, if anybodys trying to hoard then we'll get to know as we have all the data of grain and farmers-> so we can prevent hoarding by informing govt agencies or smtg
    #center architecture is the backbone of this, like we can 

Future Scope:
    i) We can use the supply demand data from each centre and couple it with the regional agricultural university data 
    and give proper guidance regarding crop selection to farmers
        (& ->since we've data of demand and supply-> we can suggest farmer what to grow, so as to maximize their profit )
    ii) There are some shortcoming owing to the time limit in hackathon whch can be worked on->
        a) Payment system, Refinement in delivery , warehouse model, etc
    iii) multilingual support

Problems with the app:
    i) multilingual support
    ii) Regfinement required in certain models like delivery, warehouse
    iii)Payment


Learnings:
    -Designing features keeping in mind simplistic and easy to use design(for farmerss)
    -Dataase design since it is a huge app with many apis
    -the skill to complete the product in stipulated time

   
Challenges:
    -we had to think of something to support sms services (twilio provides api (for sending farmers sms to server) but it is paid 
      -> we used dummy app on which we'll get farmers sms -> then this app will generate sms/.. api and it to the server {see the image roos's send!})
        (from server we are sending success msg directly to the user using api provided by msg91, as we had free-credits for the same)
    -completing product in time was a big challenge, 
        every sub module is a big thing so we tried to model it with real world as good as possible

#apis used (ie urls made) -> signup, login, uploadGrainDetails(Post), getWareHouseStorage details, placeOrder, ...



Flow-> --tell when asked
    Farmer->register-> login-> grainEntry-> customerRequestCheck->sell  store in warehouse(opt)->list warehouse->storageTransaction
    Customer-> register->login-> listOfGrain ->order 

#entities->User, Grain, Farmer, Customer, Farm, Location(can be made), DeliveryService
#transaction-> grainEntryDetail, orderDetails, storageTransaction


/*
User{
    emaildId charfield;
    pwd charfield;
    userRole choiceField;
}
--> farmer and customer details stored in same User table->
problems->
    -in orderDetails Farmer & customer both are foreignKey if common table is maintaind for both then there'll be trouble differentiating customer and farmer
sol-> specialization-> Farmer & User diff tables
*/

User{
    emaildId charfield;
    pwd charfield;
}

Farmer{
    user oneToOne User;
    location fkey Location;
   // farm foreignKey Farm;    ->wrong as it=> many Farmer->1Farm 
}

Farm{
    location  fkey Location;
    farmer foreignKey Farmer;
}

Centre {
    centreId integer,
    admin fkey User,
}

Location {
    latitude float,
    longitude float
    centreId fkey Centre,
}

Customer{
    user oneToOne User;
    location fkey Location;
}

Grain{
    name charfield;
    //life span, avg-price;
}

DeliveryService{
    name char
    basePrice (perKm) float
    facilities (text) //cold container ....
}

Warehouse {
    name char,
    warehouseOwner fkey User(//can be linked to Warehouse Owner),
    facilities (text),
    grain fkey Grain //assumption one warehouse can store only one kind of grain
    basePrice float (perkg approximate)
    location fkey Location
}
 
storageTransaction { //amount of grain farmer has stored in warehouse
    farmer foreignKey Farmer,
    grain foreignKey Grain,
    isdelivered bool,
    deliveryPartner fkey DeliveryService,//nullable
    quantity float, //quantity stored
    warehouse fkey Warehouse
    date DateTime
}

farmerStoredGrainDetail{ //amount of grain left with farmer
    grain foreignKey Grain;
    farmer foreignKey Farmer;
    quantity float;
    price float;
    quality charfield;
    date DateTime
}

orderDetails{
    aprove bool;
    isdelivered bool; //if customer needs DeliveryService
    deliveryPartner fkey DeliveryService;
    customer foreignKey Customer;
    farmer foreignKey Farmer;
    grain foreignKey Grain;
    quantity float;
    price float;
    date DateTime
}


//function implementation example->

Grain->name, lifespan
Farmer->user
farmerGrainDetail


Authentication->Session, Token

url -> request(cookie user information) Session

url -> request(header->Token) ->Token decrypt using a key : user  : jwt(json web based Token) // so its like every request will contain header file with the token in it, so as for it to be processed
key-> django Security key, {username, email }

url-> /farmer/grainUpload ->post

http request methods->
    get : to request data from the server
    post : to submit data to be processed to the server

def grainUpload(request): //grainId, quantity, quality, price
    user = request.user
    grainID = request.data["grainID"] //grainId => key that we've decided, similary quality,quantity,...
    quality = request.data["quality"]
    quantity = request.data["quantity"]
    price = request.data["price"]

    farmer = Farmer.objects.get(user=user)
    grain = Grain.objects.get(pk=grainId)

    farmerGrainDetail = FarmerGrainDetail(farmer = farmer, grain = grain, quantity = quantity,
                                            quality = quality, price = price)
    
    farmerGrainDetail.save()

    return JsonResponse({"success":true})

 #returning data in JSON(JavaScript Object Notation) format (which is implemented as dictionary objects in Python)

***

JSON : --https://beginnersbook.com/2015/04/json-tutorial/
    JSON stands for JavaScript Object Notation. JSON objects are used for transferring data between server and client, 
    XML serves the same purpose. However JSON objects have several advantages over XML.

    JSON data: It basically has key-value pairs.
        eg: var chaitanya = {
                "firstName" : "Chaitanya",
                "lastName" : "Singh",
                "age" :  "28"
            };

    Features of JSON:
        It is light-weight
        It is language independent
        Easy to read and write
        Text based, human readable data exchange format

    JSON data structure types and how to read them:
        1) JSON objects:
            var chaitanya = {
                "name" : "Chaitanya Singh",
                "age" : "28",
                "website" : "beginnersbook"
            };
            The above text creates an object that we can access using the variable chaitanya. Inside an object we can have any number of key-value pairs like we have above. We can access the information out of a JSON object like this:
            document.writeln("The name is:  " +chaitanya.name);
       
        2) JSON objects in array
        In the above example we have stored the information of one person in a JSON object suppose we want to store the information of more than one person; in that case we can have an array of objects.
            var students = [
                {"name" : "Steve", "age" :  "29", "gender" : "male"},
                {"a" : "aname", "age" : "aage", "gender":"agender"},
                .....
            ];
            To access the information out of this array->
            document.writeln(students[0].age); //output would be: 29
    
        3) Nesting of JSON objects:
            var students = {
                "steve" : {
                    "name" : "Steve",
                    "age" :  "29",
                    "gender" : "male" 
                },

                "pete" : {
                    "name" : "Peter",
                    "age" : "32",
                    "gender" : "male"
                },

                "sop" : {
                    "name" : "Sophie",
                    "age" : "27",
                    "gender" : "female"
                }
            }
        to access->
        document.writln(students.steve.age); //output: 29


******

DJANGO
    -server side web application development framework written in python

    any web app consist of two parts
        i. client side
            -any application which can request data from a server
             could be web application or android app or iOS app or any other  kind of app which can request data from the server
        ii. server side
            -a server which is runnig an application which is written in server side lang such as PHP,python,ruby and so on..
            -job of server side app is -> to respond to these request
            -so server side app will take the request ->
              get the data from db if required -> construct a response -> 
                then send it back in an appropriate format to the client 

    Architectural Pattern followed by Django
        -Django follows MVT (Model View Template) architecture.
        MVT is slight variation of MVC(Model View Controller) architecture

        #Architectural pattern is just a way of constructing the code or managing the code.
        #by seperating the code into smaller pieces it becomes easier to create bigger project so for that we use
        an Architectural pattern


        MVC:
            consist of three parts
            i. Model
                -any code that deals with the "data & business logic" 
                ie data manipulation, data validation, user authentication and anything that deals with data is
                    considered to be a part of the model 
            
            ii. View
                -Views are the UI elements
                the buttons, the images, the forms which the users sees and interact with

            iii.Controller
                -controller is a glue that sits b/w the model and the view

            => whenver a user interacts with the view -> the controller receives the request -> 
            fetches the data from model if necessary -> & creates new view or update the view with data that it receives from the model

        #MVT is similar to the MVC architecture
        Django calls :  models = models
                        Views = Template (views are called Template in django)
                        Controller = View (controller in django is called a View)

                        #just the nomanclature differs in mvc and mvt otherwise same functionality in both
    

    Project & App:
        -a project is an entire application and an app is a module inside the project 
         that deals with one specific requirement
        eg in our Krishi jag pro-> inside the proj we'll have several apps like->
            users,transaction, templates



******************************
2. https://medium.com/@neshpatel/solving-sudoku-part-i-7c4bb3097aa7



****************************************************************************************************************************

//OOPS design:

College, Branch, student(enroll), 

Flow: student->login/signup ->College->Branch->Rollno
Branch->Subjects, Faculty

class College {
    string name;
    List<Department> depts;

    College(name) {

    }

    addDepartment(Department department) {

    }
    
}

class Person {
    string name, address, contactNO, DOB;

    Person(all args) {

    }
}

class Student inherit Person {
    Rollno,
    enroll no,
    Department dept;

    Student(string name, ...) {
        Person(name,....);
        this.Rollno.....
    }

    enrollStudentinDept(Department dept) {
        this->dept = dept;
        dept.enrollStudent(this);
    }

}

class Faculty inherit Person { //same as Student
}

class Department inherit Stream{
    Faculty HOD, 
    list<Student> students; //init with empty
    list<Faculty> faculties; //init with empty

    Department(string name) {
        Stream(name);
    }

    enrollStudent(Student student) {
        students.append(student);
    }
}

class Stream {
    name, subjects
}



****************************