RabbitMQ--> 
    -RabbitMQ is a message broker: 
    it accepts and forwards messages. 
    You can think about it as a post office: 
    when you put the mail that you want posting in a post box, 
    you can be sure that Mr. or Ms. Mailperson will eventually 
    deliver the mail to your recipient. 
    In this analogy, RabbitMQ is a post box, a post office and a postman.

    -The major difference between RabbitMQ and the post office 
    is that it doesn't deal with paper, 
    instead it accepts, 
    stores and forwards binary blobs of data â€’ messages.

    -RabbitMQ, and messaging in general, uses some jargon.

    -RabbitMQ allows multiple connection channels inside 
     a single tcp connections to the message broker

Producer:
    Producing means nothing more than sending. 
    A program that sends messages is a producer:

Queue:
    A queue is the name for a post box which lives inside RabbitMQ. 
    Although messages flow through RabbitMQ and your applications, 
    they can only be stored inside a queue. 
    A queue is only bound by the host's memory & disk limits, 
    it's essentially a large message buffer. 
    Many producers can send messages that go to one queue, 
    and many consumers can try to receive data from one queue. 

Consumer:
    Consuming has a similar meaning to receiving. A
    consumer is a program that mostly waits to receive messages.

    #Note that the producer, consumer, and broker 
    do not have to reside on the same host; 
    indeed in most applications they don't. 
    An application can be both a producer and consumer, too.


AMQP: Advanced Message Queuing Protocol

    vendor A(java application)        vendor B (.net application)
                    vendor c (AMQP 1.0 Broker)
    -with the help of amqp protocol (implemented properly)
    we can communicate with different systems and different 
    applications.
    -Its a protocol for creating and handling 
    message queues
    -Interoperable, easy to swap
    -born from banking domain(JP Morgan, Barclays, Goldman Sachs etc)
    -In general very suitable protocol for 
    implementing all kinds of Even-Driven Microservices.

    -all amqp clients interoperate with all amqp servers

    #transaction => messages exchanges


    Architecture- 
    
    Publisher -(Publishes messages to the exchange)-> 
    Exchange -(receives messages and direct the to the correct queue(binding))->
    Queues --> different Conusmers                
    
    #Message Broker = Exchange + Queues
    #RabbitMQ is the implementation of 
    Message Broker part of AMPQ (written in Erlang)


    Use Cases: (amqp solves these)
        -Want a real time feed of constantly updating information?
        -want an encrypted assured transaction?
        -want your message to be delivered when the destination comes online?
        -want to send enormous message while still receiving
        status updates over the same n/w connection?
        -want things to work on all popular operating systems
        and languages? 

        #AMQP solves the technical part of connecting diverse applications altogether


    4 Actors of messaging with RabbitMQ

    Produces -(sends msg)->Exchange -(routes)->Queue
    -(deliver)->Consumer

    #msgs are piled up in queues to be sent to consumers
    #Consumer can be any application(.java,net or any cmd line application)
    waiting for the msg, which receivs the msg at the end.

    Exchanges:
        -Actual amqp elements where messages are sent at first
        -takes a message and routes it into one or more queues
        -routing algorithm decides where to send messages from exchange
        -routing algorithm depends on the exchange type and 
        rules called "bindings".
        -bindings are simply used to "bind exchanges to queues"
        for message delivery 

    Four Exchange Types:
        1. Direct Exchange: (Empty string) and amq.direct
        2. Fanout Exchange: amq.fanout 
        3. Topic Exchange: amq.topic 
        4. Headers Exchange: amq.match(and amq.header in RabbitMQ)
    

    Queues: 
        -Messages are routed to queues from exchanges
        -Queues are final destinations in RabbitMQ before 
        being received by subscriber

        Properties:
            1. Name- name of the queue
            2. Durable- either persist the queue to the disk or not
            3. Exclusive- Delete the queue if not used anymore
            4. Auto-Delete- Delete the queue when consumer unsubscribes 

    Topics: 
        -topics are the "subject" part of the messages
        -defined as routing_key for message grouping
        -Special formatting for better use:
            >app.logs.error
        -Optional parameter for message exchange
        -you can send and receive messages without 
        any topic information
        -Topic exchanges are defined using Topics for 
        message delivery

    Bindings:
        -Rules that exchanges use to route messages to queues
        -To instruct an exchange E to route messages to 
        a queue K, K has to be bound to E!
        -May have an optional routing key attribute used by some exchange
        types.
        -So the routing key acts like a filter
        
        #If message cannot be routed to any queue(there are no bindings)
        for the exchange it was published to) it is either 
        dropped or returned to the publisher, depending
        on message attributes the publisher has set.




***
Publishing message to queue steps:
    1. making connection to rmq server  ->     ConnectionFactory factory = new ConnectionFactory();
    2. getting a new connection         ->     Connection connection = factory.newConnection();
    3. Creating a channel as everything
        passes through a channel        ->     Channel channel = connection.createChannel();

    4. Declaring queue                  ->      channel.queueDeclare(queue: "queueName", durable: true/false, exclusive:t/f, autoDelete: t/f, arguments:null);
    5. publishing message to queue      ->      channel.basicPublish(exchange:"", routingKey: "queueName", mandatory:t/f, props:null, payload.getBytes)
                                                //last arg-> message to be seng in byte format, payload.getByte->converting String payload to byte
    




**************************************ZOOKEEPER******************************************************

#while running a distributed system every client has to have the consistent picture of
who the master node is that its writing through, if you have more than one master
responding at a time you can get very inconsistent behaviour in your database. So, if
you're building a system where you care about consistency, you need to have some sort
of a system outside your system that's keeping track of all of these things. So,
In addition to
    >which node is master server,
    >what tasks are assigned to which workers,
    so if a worker fails how do i know where to pick up from when i redistribute that work,
    >which workers are currently available

    #so basically its an external tool that applications like HBase can use to recover
    from partial failures in your cluster

Zookeeper:
    -It keeps track of information that must be synchronized across your cluster
        >which node is the master?
        >what task are assigned to which workers?
        >which workers are currently available?
    -Its a tool that applications can use to recover from partial failures in your cluster
    -An integral part of HBase, High-Availability(HA) MapReduce, Drill, Storm, Solr and much more.

    Failure Modes:
        1. Master Crashes, needs to fail over to a backup
            -Zookeeper can keep track of who the current master is and if that master goes down
            automatically detect that it's no longer responsive and let these other masters try to
            make themselves a new master but only allow one to actually win that race


        2. Worker crashes- its work needs to be redistributed
            -zookeeper can keep track of this type of failure as well, like
            if it does not respond for a while it can detect it and know there's
            something wrong with this worker might be disconnected or something
            and then it can notify your application that that happened and then your
            application can redistribute the work accordingly

        3. Network trouble- part of your cluster cant see the rest of it.
            -can detect different sorts of failures of communication.
            (can be between different nodes)


    Primitive operations in a distributed System:
        1. Master Election:
        2. Crash Detection:
        3. Group Management:
        4. Metadata:



