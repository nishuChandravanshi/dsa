**********************************
Reference in28minutes.com @Udemy:
https://github.com/nishuChandravanshi/java-tutorial-for-beginners
**********************************


Introduction:

//https://www.guru99.com/java-virtual-machine-jvm.html  #awesom explanation
JVM (Java Virtual Machine):
    -a engine that provides runtime environment 
    to drive the Java Code or applications. 
    -It converts Java bytecode into machines language.
    -JVM in java is responsible for allocating
    memory space.
    -it resides on RAM
    -it is a part of JRE(Java Run Environment)


    How it works: 
        >javacode -(compiler)-> bytecode -(this bytecode gets
        interpreted on different machines)
        >JVM workflow: (jvm architecture contains-->)
            class loader --> Byte Code Verifier --> Execution Engine
    
        #b/n host system and java source, Bytecode is an intermediary language.

    C code compilation and execution process:
        .c files -(compiler)-> respective .obj files -(linker)->
        .exe file -(loader)->loads exe file into RAM for execution
        
        #linker combines all the object files (.obj) together
        and produces .exe file

    JAVA Code Compilation and Execution in JVM:
        .java files -(compiler)-> corresponding .class files
        -> during execution these class files are loaded into RAM
        by class loader ->these class files ie bytecode are then verified
        for security breach -->execution engine converts bytecode into Native Machine code***
        -->which is then executed

        *** this is JIT (just in time compilling)
            >this is one of the main reason y java is comparitively slow
        #No linking is done
        #.class consists of BYTE code
        #JVM resides on the RAM
        #JIT is a part of JVM


#In other programming languages, 
  the compiler produces machine code for a particular system.
  However, Java compiler produces code for a 
  Virtual Machine known as Java Virtual Machine.


----------------OOPs----------

Class:
    blueprint of object


Packages
    -mechanism to keep group of classes, interfaces and
    sub-packages which has similar functionalitites
    at the same place
    -provides folder structure to organise classes-interfaces


Interfaces
    -It is a blueprint of a class, 
    specifies what a class must do(not how)    
    -does not have implementations of methods
        >ie there r only method declarations
        >all methods are abstract and public by default

    -Syntax:
        <modifier> interface InterfaceDemo{
            public void m1(); //these methods are by default Abstract and Public
            public void m2();
        }        
        >data members inside interface are always static final
    - keyword "implement" is used to implement the interface inside a class
        like: 
            class Test implements InterfaceDemo{
                @Override //the abstract methods must be implemented in this class 
                public void m1()
                {

                }
                @Override
                public void m2()
                {

                }
            }
        #ie by implementing an interface it is must that
        we Override the abstract methods of the interface

        #if we do not want to implement all the methods of the interface 
        we can also make the class(which is implementing interface) as abstract class
        , but then we cannot create the object of abstract class,
        just like that of interfaces
        like:
            abstract class Test implements InterfaceDemo{
                @Override 
                public void m1()
                {

                }
                //since now class Test is itself abstract class
                //we do not need to Override all the methods here
            }

    #if every method is Abstract then the interface
    can be called as "pure abstract class"
    #Until Java 1.7:
        interfaces->abstract methods :(called Pure abstract class)
    #After Java 1.8 
        interfaces-> abstract, default, static methods
    
    #After Java 1.9 
        Interfaces-> abstract, default, static, private methdos (can also be defined inside interfaces)


Difference b/w Abstract Classes and Interfaces
    Abstract classes:
        -Can extend one abstract class.
        -Can have abstract methods and concrete methods
        -'abstract' keyword required in declaration
        of abstract methods
        -Can have static, final or static final
        variables with any access specifier


    Interfaces:
        -Can implement any number of interfaces
        -Can have abstract methods, static, default, private
        methds. (not concrete methods)
        -'abstract' keyword not required, as by 
        default all methds are abstract
        -Can have only static final variable by default


    #Use Interfaces-> when we want to create a service
    requirement specification(srs) for any class,
    ie the blueprint of any class to specify what a class
    must do.
    #Use Abstract Classes-> to provide a base for subclasses
    to extend and implement the abstract methods,
    and use the implemented methods which are defined in abstract
    class



Abstract Class
    -while we create a method inside a
    class we provide its implementation
    - Abstract class provide a feature using
    which we dont need to provide implementations
    of a few methods.

    eg. 
    1. class AbstractAnimal{
        public void bark(); //left unimplemented
    }
    >o/p: Error: missing method  body, or declare abstract

    2. class AbstractAnimal{
        abstract public void bark(); //abstract method
    }  
    >o/p: Error: AbstractAnimal is not abstract and
    does not override abstract method bark() in AbstractAnimal

    3. abstract class AbstractAnimal{ 
        abstract public void bark(); 
    }
    >o/p: created class AbstractAnimal
        #here we created abstract class with bark 
        method without providing its implementation
        , implemention will be provided by the subclass(es)

    4. class Dog extends AbstractAnimal{

    }
    >o/p: Error: Dog is not abstract and does not override 
    method bark() in AbstractAnimal

        ##inorder to extend abstract class
        , the subclass need to provide implemention 
        of its abstract methods

    5. class Dog extends AbstractAnimal{
        public  void bark()
        {
            System.out.println("bhaw bhaw");
        }
    }
    >o/p: created class Dog

    6. Dog dog = new dog;
    dog.bark();
    >op: bhaw bhaw

    #we cant create instance of abstract class
    ie eg. 
        AbstractAnimal animal = new AbstractAnimal(); // not allowed
        >op: Error: //... AbstractAnimal is abstract: cant be instantiated

    #abstract class can have non abstract methods as well

    eg. 
    abstract class AbstractDemo { // Abstract class
        private int i = 0;
        public void display() { // non-abstract method
            System.out.print("Welcome to Tutorials Point");
        }
    }
    public class InheritedClassDemo extends AbstractDemo {
        public static void main(String args[]) {
            AbstractDemo demo = new InheritedClassDemo();
            demo.display();
        }
    }
    #For an abstract class, 
    we are not able to create an object directly.
    But Indirectly we can create 
    an object using the subclass object.
    
    #Declaring a class as abstract with no abstract 
    methods means that we don't 
    allow it to be instantiated on its own
    
    #An abstract class used in Java signifies that 
    we can't create an object of the class directly.




Inheritence
    # by default every class inherits Object class in java implicitly
    ie its(Object class) is the root of the class hierarchy
        eg. class Person{ //-->same as -> class Person extends Object //since every class by default inherits Object class
            private String name;
            //...
        }
        class Student extends Person{  // here we see we're inheriting Person class into Student class, and in Person class already inherits Object class => it also contains Object class features
            private collegeName;
            //...
        }

    # whenever we create an object of a subclass-> super class constructor is 
    automatically called

    # we can have a superclass reference variable
    that can hold a subclass variable
    but, the vice versa is not allowed
        eg.
        class Animal{
            //....
        }
        class Dog extends Animal{
            //...
        }

        class Runner{
            Animal animal = new Dog(); //valid
        }




*********************************************

Variables
    1. Instance Variables:
        -defined inside class, but outside methods
        -scope remains inside the class in any method or block or constuctor
       -initialized whenever we create an object, and
        for each object a new copy of this variable is allocated

    2. Local Variables:
        -defined inside methods/block/constuctor 
        -scope limited to that particular method/block where being defined
        -initialized when that method is called
    3. Static Variables:
        -defined inside class, outside method but with 
        'static' keyword
        -belongs to the whole class, not to the object
        -scope remains inside the class 
        -initialized only once at the start of execution
        -for all the objects only one copy of variable
        gets allocatedto all the objects


# we can use access modifiers with instance Variables
but not with local Variables as its scope is already defined(
    ie scope of local variable is only within the mthod/block/.. within
    which it has been defined
)


Constructors
    -used to initialize variables at runtime
    tyeps:
        1. Default Constructor,
        2. Parameterised Constructor
        3. Non-Parameterised Constructor
    
    # Constructors cannot be abstract,final or static
    # static methods are used to access static members
    
Modifiers
    -modifiers se the accessibility of classes
    or methods or any members
    
    1. Access modifiers:
        -specifies the scope of particular members
        -the behaviour of class is specified using modifiers
        types:
            1. Public:
                -the class can be accessed anywhere
            2. Private
            3. Protected:
                -can be accessed everywhere within the 
                same package and its subclasses, but cant 
                be accessed in other packages except its subclasses
                (as the subclasses can be anywhere within the 
                same package or other package)
                #outside the package it(Protected members) can be 
                used only with childs reference(ie reference of its child class)
                , while inside the package it can be accessed by both
                childs reference or by parents reference
            4. Default
                -the scope of Default classes is 
                within their package
            
            #public class can be accessed anywhere 
            whereas the default class can be accessed 
            within its package only

    2. Non-Access modifiers:
        
        1. Abstract keyword:
            -abstract modifier is applicable for classes and methods
            -Abstract method:
                >doesnt have  implementation (ie no body)
                >implementation to an abstract method
                is provided in its child class(ie subclass)
            -Abstract class:
                >Not fully implemented
                >we can not create object of abstract class
                    >>ie abstract classes cannot be instantiated
                >we have to create the implementation of abstract class
                in the child class
                > We can also create concrete methods in abstract classes,
                these methods will be available to all its child classes 

                Adv:
                    1. Code Reusability:
                        -as a method can be kept in abstract class
                        then multiple classes can extend and use that method
                    2. used to achieve abstraction in java

            #to write an abstract method in a class
            that class must be abstract too
            #however, it is not mandatory to have atleast one abstract method
            inside abstract class
            #we can declare any class as abstract if the implementation
            is not complete

            # ie when we want a base class which should not be instantiated
            and have some common functionality for each of its derived class 
            with different implementations, we use abstract classes and abstract methods         
        #abstract methods can only be defined in abstract class
   
        #public class can be used outside the package in which
        its defined too

        2. Final Keyword:
            -Non-access modifier which is applicable for classes, 
            variables and methods and used to finalising the implementation
            of them
        

        3. Static keyword:
            -applicable for variables and methods,
            and used to define the class members
            independent from any instances

*****************************
Wrapper Classes:
    -A wrapper class wraps(encloses) around a data
    type and gives it an object appearance 
        >used to give primitive data types object appearance
    -Wrapper classes are final and immutables

    Types:
        1. Wrapper: Boolean, Byte, Character, Double, Float, Integer, Long, Short
        2. Primitive: boolean, byte, char, double, float, int, long, short

    #In java there are corresponding classes for 
    each of these primitive data types, called as 
    Wrapper classes
    
Why Wrapper Classes?
    -Creation from other data types

    Integer hundred = Integer.valueOf("100");
    Boolean value = Boolean.valueOf("True");


#We should use "valueOf" instead of using "new"
in wrapper classes


********************************************

Auto-Boxing:

****************************************
Java 8 brings date time classes as follows->

1. LocalDate:
    -can hold a date eg. 30-03-2021
    -immutable(all three of these are immutables)
    eg:
        import java.time.LocalDate
        LocalDate now = LocalDate.now();
        o/p-> 2021-03-30 (current date)

2. LocalDateTime
    -represents both date and time
3. LocalTime

    #these are inside a package called java.time

    # /imports -> lists few default imports

**********************************************

Array and ArrayList

Array
    -Syntax:
        int []marks = new marks[5]  //size must be declared in definition side(ie right side)
        //declaration  //definition side 
        //side
        - int[] marks = {2, 3, 4, 5, 9}; 
    
    #By default array is init-ialized with 0,
    # in case of Array of objects default value is 'null'

    -to print all the elements of array with system.out.print
        
        -System.out.print(Arrays.toString(marks)); 
            >o/p [2,3,4,5,9] 
        
        #System.out.println(marks) -> will return the base address of array



    -Changing content of an array: 
        
        Arrays.fill(marks,100); //all array values will be set to 100,
                                //modify in bulk

    -Compare Arrays
        Arrays.equals(array1,array2);
        >o/p: true/false 

    -Sort Array
        Arrays.sort(arr1);

Variable Number of Arguments:
    -say we dont know the number of Arguments to pass in a function
    we can pass it like ->(int... values) //now wtever
    number of Arguments passed in values will be considered
    in the form of list as->

    void print(int... values)
    {
        System.out.println(Arrays.toString(values));
    }
    >o/p: list of int values being passed in print

    #variable argument should be the last argument



## The problem with array is that we cannot directly delete or insert 
new elements into it onces its created
->inorder to do that we need to make a new array 
of size greater than previous(incase of insertion)
or size less than previous(incase of deletion), and 
then copy the reqd elements into this new array from
the previous one

    --> here comes ArrayList

ArrayList
    >provide features to add and remove elements
    from array dynamically

    -syntax for instance creation:

        > ArrayList arrayList = new ArrayList(); // can store mixed data type valuse eg ["a", "bcd", 1, 2.3]
        > ArrayList<String> arrayList = new ArrayList(); //can store only string type values
    -functions:
        >arrayList.add("a"); //can add any datatype
        >arrayList.remove("a"); //or arrayList.remove(0); -> ie can specify index as well




******************************************
Collections : (List, Set, Queue, Map,...)
    -the underlying data structures are very complex(Arrays etc)
    , even inserting/deleting a simple thing into array
    involves writing a lot of code.
    -Java provides implementations of these data structures
    called Collections

    #as array size once allocated cant be changed dynamically


    List:
        -Cares about which position each object is in
        -Elements can be added in by specifying position-
        where should be it added in 
        -If element is added without specifying position-
        it is added at the end
        eg:

        //java9
        List<String> words = List.of("Apple","Bat","Cat");
        words.size() //in array or like that we have length, but in Collections we have size()
        >3

        words.isEmpty();
        >false
        
        words.get(0)
        >Apple
        
        words.contains("Dog")
        >false

        words.indexOf("Cat")
        >2

        words.indexOf("Dog")
        >-1

    #anything created using of function(eg List.of("..")) is immutable

        words.add("Dog")
        >UnsupportedOperationException


    ##ie inorder to create a MUTABLE list following
    are the choices-->
        ArrayList, LinkedList, Vector

    eg. 
    List<String> wordsArrayList = new ArrayList<String>(words)
    wordsArrayList.add("Dog")
    >true  //wordsArrayList-> ("Apple","Bat","Cat", "Dog")

    List<String> wordsLinkedList = new LinkedList<String>(words);

    List<String> wordsVector = new Vector<String>(words)


    ArrayList:
        -iteration faster(ie search faster) than LinkedList 
        -insert, delete slower than LinkedList
        -underlying data structure -> Array
    
    LinkedList:
        -underlying data structures -> doubly LinkedList

    ##if we gotta access the elements based on their positions
    go for ArrayList,
    ##if there're number of insertion and deletions,
    go for LinkedList


    Vector vs ArrayList:
        class Vector implements List<E>{
            //Thread safe - Synchronized methods
            //almost constant time - access
        }
        -use vector in situation where data is shared
        b/w multiple threads

        -ArrayList is not thread safe

        #unless we need thread safety-> go for ArrayList


**************************
List
    -implements collection interface
    -cares about which position each object is in
    -Elements can be added in by specifying position-
    where should it be added in
    -If element is added without specifying position
    ,it is added at the end

    List Interface->

    interface List<E> extends Collection<E>{
        //.........
        get()
        set()
        add()
        remove()
        indexOf()
        lastIndexOf()
        ...//etc etc
    }
##different implementations of list
    1. ArrayList
    class ArrayList implements List<E>{
        //uses array as underlying ds
        //insertion and deletion are slower compared to LinkedList
        //almost const time -access
    }

    2. LinkedList
    class LinkedList implements List<E>{
        //uses doubly linked list as underlying ds
        //Faster insertion and deletion 
        //Iteration slower than ArrayList
    }

    3. Vector
    class LinkedList implements List<E>{
        //Tread Safe - achieves thread safety by using Synchronized methdos
        //all the methods in vectors are Synchronized
        //almost const time -access

    }


************************************************
Exception Hierarchy

//Pre-defined Java Classes
class Error extends Throwable{}
class Exception extends Throwable{}
class InterruptedException extends Exception{}
class RuntimeException extends Exception{}
class NullPointerException extends RuntimeException{}


#Errors can not be handled by the programmer. 
#ie you can prevent Errors but not handle them.
#Exception are things which programmers may be able to handle

Exception types-
    1. Unchecked Exceptions: Runtime Exceptions and its subclasses
    2. Checked Exceptions : exceptions which are under exceptions but not 
     runtime exceptions(ie exception which are subclasses of Exception but not of RuntimeException)
        eg. InterruptedException
        #InterrruptedException and any of its subclass
        will be called CheckedException. 

    #when any method throws CheckedException calling method
    should either handle it or throw it as well


 *********
 Java Modularization:
    -Introduced in Java8
    Goals:
        >Modularize JDK(IMPORTANT)
            >>rt.jar gre to 60+MB by java8 (which was much lesser earlier)
        >Modularize applications 
    
    Modularizing JDK: 
        >java --list-modules  //command 
            >>java.base
            >>java.logging
            >>java.sql
            >>java.xml
            >>jdk.compiler
            >>jdk.jartool
            >>jdk.shell 
            etc...

        #can see all the modules with name starting with 
        java are the modules related with programming, 
        all the modules which starts with jdk are some kind
        of tool eg jdk.compiler is used to compile the programming, 
        jdk.jartool used to build the jar file, jdk.shell is the
        module for jshell

    >java -d java.sql //command
        >>exports java.sql
        >>exports javax.sql
        >>requires java.logging transitive 
        >>requires java.base mandated 
        etc etc...


***********************************************
HASHING:
    -improvement of Direct Access Table
    -provides O(1) time on average for insert, 
    search and delete

Hash Function:
    -maps a big number or a string to a small 
    integer that can be used as index in 
    hash table
    eg. h(x)  = x mod n;
    where, x -> our input number 
           
Good h(x) should be->
    -should compute efficiently
    -should uniformly distribute the keys


Collision:
    -same key for different values


Collision Handling/ Collision Resolution

Chaining/ Open Chaining 
    -the idea is to make each cell of hash table
    point to a linked list of records that have same 
    hash function
    -linked list,
    disadv:
        -extra space

Closed Chaining / Open Addressing:
    -All elements are stored in hash table itself
    1. Linear Probing (h(x)+i)
    2. Quadratic probing (h(x)+i^2)
    3. Double Hashing

    where i = number of probes (or number 
    of attempts in search of a particular key)




******************************************************************
Java Interview Questions

1. In Java, the java file name should be always the same as a public class name, why?
    -While writing a java program first it is saved
     as a ".java" file, when it is compiled it forms 
     byte code which is a ".class" file as such that
     if we made our program file similar to the class 
     it will be comfortable for us to understand without 
     any ambiguity. We are allowed to use any name for a 
     filename only when class is not public. In the case 
     of a public class, we canâ€™t use a different file name.
    -The filename must have the same name as the public 
    class name in that file, which is the way to tell 
    the JVM that this is an entry point.
    -Suppose when we create a program in which more than
     one class resides and after compiling a java source
     file, it will generate the same number of the 
     .class file as classes reside in our program. 
     In this condition, we will not able to easily 
     identify which class need to interpret by java 
     interpreter and which class containing 
     Entry point for the program


2. OOPs Design:


------------------------ADVANCE JAVA-------------------------------------------------

//https://www.youtube.com/watch?v=twBe8SQHGTc&list=PLX9Zi6XTqOKR9OnWzkGUI0howsUruEe45&index=2
JDBC - Java DataBase Connectivity
    -The JDBC API defines interfaces and 
    classes for writing db applications in Java 
    by making db connections
    
    #Application data refers to set of information
    which comes in the scope of application.
    eg. say ATM m/c needs data like a/c number, 
    a/c details etc etc (ie in the scope of its application).
    It doesnt care about the Data such as whos 
    the prime minister of india. lol:D  

