----------------OOPs----------

Class:
    blurint of object

Variables
    1. Instance Variables:
        -defined inside class, but outside methods
        -scope remains inside the class in any method or block or constuctor
       -initialized whenever we create an object, and
        for each object a new copy of this variable is allocated

    2. Local Variables:
        -defined inside methods/block/constuctor 
        -scope limited to that particular method/block where being defined
        -initialized when that method is called
    3. Static Variables:
        -defined inside class, outside method but with 
        'static' keyword
        -belongs to the whole class, not to the object
        -scope remains inside the class 
        -initialized only once at the start of execution
        -for all the objects only one copy of variable
        gets allocatedto all the objects


# we can use access modifiers with instance Variables
but not with local Variables as its scope is already defined(
    ie scope of local variable is only within the mthod/block/.. within
    which it has been defined
)


Constructors
    -used to initialize variables at runtime
    tyeps:
        1. Default Constructor,
        2. Parameterised Constructor
        3. Non-Parameterised Constructor
    
    # Constructors cannot be abstract,final or static
    # static methods are used to access static members
    
Modifiers
    -modifiers se the accessibility of classes
    or methods or any members
    
    1. Access modifiers:
        -specifies the scope of particular members
        -the behaviour of class is specified using modifiers
        types:
            1. Public:
                -the class can be accessed anywhere
            2. Private
            3. Protected:
                -can be accessed everywhere within the 
                same package and its subclasses, but cant 
                be accessed in other packages except its subclasses
                (as the subclasses can be anywhere within the 
                same package or other package)
                #outside the package it(Protected members) can be 
                used only with childs reference(ie reference of its child class)
                , while inside the package it can be accessed by both
                childs reference or by parents reference
            4. Default
                -the scope of Default classes is 
                within their package
            
            #public class can be accessed anywhere 
            whereas the default class can be accessed 
            within its package only

    2. Non-Access modifiers:
        
        1. Abstract keyword:
            -abstract modifier is applicable for classes and methods
            -Abstract method:
                >doesnt have  implementation (ie no body)
                >implementation to an abstract method
                is provided in its child class(ie subclass)
            -Abstract class:
                >Not fully implemented
                >we can not create object of abstract class
                    >>ie abstract classes cannot be instantiated
                >we have to create the implementation of abstract class
                in the child class
                > We can also create concrete methods in abstract classes,
                these methods will be available to all its child classes 

                Adv:
                    1. Code Reusability:
                        -as a method can be kept in abstract class
                        then multiple classes can extend and use that method
                    2. used to achieve abstraction in java

            #to write an abstract method in a class
            that class must be abstract too
            #however, it is not mandatory to have atleast one abstract method
            inside abstract class
            #we can declare any class as abstract if the implementation
            is not complete

            # ie when we want a base class which should not be instantiated
            and have some common functionality for each of its derived class 
            with different implementations, we use abstract classes and abstract methods         
        #abstract methods can only be defined in abstract class
   
        #public class can be used outside the package in which
        its defined too

        2. Final Keyword:
            -Non-access modifier which is applicable for classes, 
            variables and methods and used to finalising the implementation
            of them
        

        3. Static keyword:
            -applicable for variables and methods,
            and used to define the class members
            independent from any instances

Packages
    -mechanism to keep group of classes, interfaces and
    sub-packages which has similar functionalitites
    at the same place
    -provides folder structure to organicse classes-interfaces



Interfaces
    -It is a blueprint of a class, 
    specifies what a class must do(not how)    
    -does not have implementations of methods
        >ie there r only method declarations
        >all methods are abstract and public by default

    -Syntax:
        <modifier> interface InterfaceDemo{
            public void m1(); //these methods are by default Abstract and Public
            public void m2();
        }        
        >data members inside interface are always static final
    - keyword "implement" is used to implement the interface inside a class
        like: 
            class Test implements InterfaceDemo{
                @Override //the abstract methods must be implemented in this class 
                public void m1()
                {

                }
                @Override
                public void m2()
                {

                }
            }
        #ie by implementing an interface it is must that
        we Override the abstract methods of the interface

        #if we do not want to implement all the methods of the interface 
        we can also make the class(which is implementing interface) as abstract class
        , but then we cannot create the object of abstract class,
        just like that of interfaces
        like:
            abstract class Test implements InterfaceDemo{
                @Override 
                public void m1()
                {

                }
                //since now class Test is itself abstract class
                //we do not need to Override all the methods here
            }

    #if every method is Abstract then the interface
    can be called as "pure abstract class"
    #Until Java 1.7:
        interfaces->abstract methods :(called Pure abstract class)
    #After Java 1.8 
        interfaces-> abstract, default, static methods
    
    #After Java 1.9 
        Interfaces-> abstract, default, static, private methdos (can also be defined inside interfaces)




Difference b/w Abstract Classes and Interfaces

Abstract classes:
    -Can extend one abstract class.
    -Can have abstract methods and concrete methods
    -'abstract' keyword required in declaration
    of abstract methods
    -Can have static, final or static final
    variables with any access specifier


Interfaces:
    -Can implement any number of interfaces
    -Can have abstract methods, static, default, private
    methds. (not concrete methods)
    -'abstract' keyword not required, as by 
    default all methds are abstract
    -Can have only static final variable by default


    #Use Interfaces-> when we want to create a service
    requirement specification(srs) for any class,
    ie the blueprint of any class to specify what a class
    must do.
    #Use Abstract Classes-> to provide a base for subclasses
    to extend and implement the abstract methods,
    and use the implemented methods which are defined in abstract
    class

******************************************

Wrapper Classes:
    -A wrapper class wraps(encloses) around a data
    type and gives it an object appearance 
    -Wrapper classes are final and immutables

    Types:
        1. Wrapper: Boolean, Byte, Character, Double, Float, Integer, Long, Short
        2. Primitive: boolean, byte, char, double, float, int, long, short

    #In java there are corresponding classes for 
    each of these primitive data types, called as 
    Wrapper classes
    
Why Wrapper Classes?
    -Creation from other data types

    Integer hundred = Integer.valueOf("100");
    Boolean value = Boolean.valueOf("True");


#We should use "valueOf" instead of using "new"
in wrapper classes


********************************************

Auto-Boxing:

****************************************
Java 8 brings date time classes as follows->

1. LocalDate:
    -can hold a date eg. 30-03-2021
    -immutable(all three of these are immutables)
    eg:
        import java.time.LocalDate
        LocalDate now = LocalDate.now();
        o/p-> 2021-03-30 (current date)

2. LocalDateTime
    -represents both date and time
3. LocalTime

    #these are inside a package called java.time

    # /imports -> lists few default imports

**********************************************

Array and ArrayList

Array
    -Syntax:
        int []marks = new marks[5]  //size must be declared in definition side(ie right side)
        //declaration  //definition side 
        //side
        - int[] marks = {2, 3, 4, 5, 9}; 
    
    #By default array is init-ialized with 0,
    # in case of Array of objects default value is 'null'

    -to print all the elements of array with system.out.print
        
        -System.out.print(Arrays.toString(marks)); 
            >o/p [2,3,4,5,9] 
        
        #System.out.println(marks) -> will return the base address of array



    -Changing content of an array: 
        
        Arrays.fill(marks,100); //all array values will be set to 100,
                                //modify in bulk

    -Compare Arrays
        Arrays.equals(array1,array2);
        >o/p: true/false 

    -Sort Array
        Arrays.sort(arr1);
