FIRST MAKE THE DOTS, THEN START PLOTTING THE MAP!
-1.last page of the book->quiz/question
-2. bolds
-3. beginning -> first para->last para.
-4.start now.
****
USER -> USER PROGRAM -> COMMAND INTERPRETER(eg shell) -> OS <-> HW (hardware)
    
    -user does not directly interact with os, there's an interface called COMMAND INTERPRETER
    -COMMAND INTERPRETER is a program that interprets the cmd of user.
    there are 2 types of cmd interpreter based OS
        1. text based os - DOS, UNIX
        2. GUI based os - windows, MAC
 
*main goal of os is user's CONVINIENCE. secondary is efficiency
*windows os is more convinient but unix os is more efficient

throughput 
    -no. of instructions performed per unit time

************
PROCESS
#http://courses.cs.vt.edu/csonline/OS/Lessons/Processes/index.html

program- 
    static set of directions or instructions
process - 
    the dynamic activity whose properties change as time progresses

-A process is an instance of program in execution
For example a Web Browser is a process, a shell (or command prompt) is a process.
-A process encompasses(keeps) the current status of the activity, called the process state.
-process state includes
    -the current position in the program being executed (the value of the program counter)
    -other CPU registers and the associated memory cells
    - process state is a snapshot of the machine at that time. At different times during the execution of a program(at different times in a process) different snapshots (different process states) will be observed

process table-
    -To keep track of the state of all the processes, the operating system maintains a table known as the process table. 
    -Inside this table, every process is listed along with the resources the processes is using and the current state of the process.

PROCESS CONTROL BLOCK(PCB)
    -ds which stores the info about a particular process. this info is reqd by the cpu while executing the process
    -each process is identified by its own pcb, is also known as CONTEXT OF THE PROCESS
    -pcb of all process are present in the LINKED LIST
    -info stored in pcb are-
        1. process id (pid) :When a process is created, a unique id is assigned to the process which is used for unique identification of the process in the system.
        2. program counter(pc): contains address of the next instruction to be executed
        3. process state : new/ready/running/waiting
        4. priority :
        5. general purpose registers (GPR): Every process has its own set of registers,
           which are used to hold the data which is generated during the execution of the process.
        6. list of open files: During the Execution, Every process uses some files which need to be present in the main memory. 
           OS also maintains a list of open files in the PCB
        7. list of open device: OS also maintain the list of all open devices which are used during the execution of the process
        8. protections:
        *first 7 are important

STATES OF PROCESS
    running state-
        the process has all the resources it need for execution and it has been given permission by the operating system to use the processor.
        Only one process can be in the running state at any given time

    ready state-
        -waiting for permission to use the processor

    waiting state-
        -waiting for some external event to occur such as user input or a disk access

    #the waiting and ready states are implemented as QUEUES which hold the processes in these states

degree of multiprogramming 
    -the no. of processes present in main memory at any point of time

scheduler in os (long term scheduler, short term, mid term)
        1                   2                  3                4 
    - new state -(LTS)-> ready state -(STS)->running -(MTS)-> waiting {or waiting -(MTS)->running}
    -ie  1->2:lts,
         2->3: sts, (also kns as DISPATCHER) 
         3->4(or 4->2): mts - performs swapping (main memory <-> secondary memory)
    
    #DISPATCHER : responsible for saving the context of one process and loading the context of other process

SCHEDULING
    -The responsibility of determining how to allocate processor time among all the ready processes is known as scheduling

    PREEMPTIVE (running state <-> ready state)    
        -one approach to scheduling known as preemptive scheduling: "this task is accomplished by dividing time into short segments, each called a time slice or quantum (typically about 50 milliseconds), 
        and then switching the CPU's attention among the processes as each is allowed to execute for no longer than one time slice
        -context switching
            -This procedure of swapping processes is called a process switch or a context switch.

    NON PREEMPTIVE (ready state -> running state)
        - processes are give control of the processor until they complete execution or voluntarily move themselves to a different state

    strategies for scheduling-

    First Come First Serve Scheduling (FCFS)
        This non-preemptive scheduling algorithm follows the first-in, first-out (FIFO) policy.
        As each process becomes ready, it joins the ready queue. When the current running process finishes execution, 
        the oldest process in the ready queue is selected to run next.
        ADV-
            -simple to use
            -easy to implement, can be implemented using QUEUE
            -does not lead to starvation
            #starvation
                -Starvation or indefinite blocking is phenomenon associated with the Priority scheduling algorithms, 
                in which a process ready to run for CPU can wait indefinitely because of low priority.
                
                *solution to starvation : AGING
                    -a technique of gradually increasing the priority of processes that wait in the system for a long time.
                *diff b/w deadlock and starvation
                    -When deadlock occurs no process can make progress, while in starvation apart from the victim process other processes can progress or proceed.
                

        DISADVANTAGE
            -doesnt consider priority or burst time (BT: time reqd by process for running on CPU,execution time)
            -suffers from CONVOY EFFECT (avg waiting time increases if job taking place first has large BT)

    Round Robin Scheduling
        This scheduling policy gives each process a slice of time (i.e., one quantum) before being preempted.
        As each process becomes ready, it joins the ready queue.
        A clock interrupt is generated at periodic intervals.
        When the interrupt occurs, the currently running process is preempted,
        and the *oldest process in the ready queue is selected to run next. The time interval between each interrupt may vary.

    SHORTEST JOB FIRST 
        -preemptive 
            adv - gurantees MINIMUM AVG WAITING TIME
            disadv - not practical, as BT of process cant be knows before hand
        -non preemptive
        Shortest Process Next(srtf shortest remainig time first)
            This non-preemptive scheduling algorithm favors processes with the shortest expected execution time.
            As each process becomes ready, it joins the ready queue. When the current running process finishes execution,
            the process in the ready queue with the shortest expected execution time is selected to run next.

    HRRN (Highest Response Ratio Next) Scheduling
        -the scheduling is done on the basis of an extra parameter called Response Ratio. A Response Ratio is calculated for each of the available jobs and 
        the Job with the highest response ratio is given priority over the others.
        - non-preemptive algorithm
        -one of the most optimal scheduling algorithms
        -its mode is non preemptive hence context switching is minimal in this algorithm

        #calculation of Response Ratio
        
            Response Ratio = (W+S)/S   
        where, W = waiting time, S = Service time or BT (burst time)
        eg. of HRRN: javatpoint.com/os-hrrn-example

        *can notice that: job with the shortest BT will be given priority but it is also including an extra factor which is W (ie waiting time)
        

    PRIORITY SCHEDULING
        -there is a priority number assigned to each process
        -The priority number assigned to each of the process may or may not vary
        -Process with the higher priority among the available processes is given the CPU
        TYPES of priority scheduling
            1. PREEMPTIVE
            2. NON-PREEMPTIVE
            *The difference between preemptive priority scheduling and non preemptive priority scheduling is that, 
            in the preemptive priority scheduling, the job which is being executed can be stopped at the arrival of a higher priority job.
            *Once all the jobs get available in the ready queue, the algorithm will behave as non-preemptive priority scheduling, 
            which means the job scheduled will run till the completion and no preemption will be done.
        
        TYPES OF PRIORITY
            1. static - priority number doesn't change itself throughout the process, it is called static priority
            2. dynamic- priority no. keeps changing itself at the regular intervals
        

PURPOSE OF SCHEDULING
    -to increase CPU utilization
    -decrease turn around time (TAT =  CT - AT (completion time - arrival time))
    -minimize response time



THREADS VS PROCESS

THREADS
    -A thread is a single sequence stream within in a process
    -popular way to improve application through parallelism.
    - The CPU switches rapidly back and forth among the threads giving illusion that the threads are running in parallel.
    -Each thread has its own program counter (PC), a register set, and a stack space.
    -Threads are not independent of one other like processes
        as a result threads shares with other threads their code section, data section, OS resources  also known as task, 
        such as open files and signals.

    ADV - threads can share common data, they do not need to use interprocess communication.
        - context switching
        -sharing

Similarities
    -Like processes threads share CPU and only one thread active (running) at a time.
    -threads within a processes, threads within a processes execute sequentially.
    -Like processes, thread can create children.
    -And like process, if one thread is blocked, another thread can run.(???DISCUSS)
Differences
    -Unlike processes, threads are not independent of one another.
    -Unlike processes, all threads can access every address in the task .
    -Unlike processes, thread are design to assist one other. 
    Note that processes might or might not assist one another because processes may originate from different users


*benefits of multithreaded programming
    -It makes the system more responsive and enables resource sharing.
    It leads to the use of multiprocess architecture.
    It is more economical and preferred



*********************************************************************
DEADLOCK
    -a situation in operating systems when there are two or more processes
    hold some resources and wait for resources held by other(s).

conditions
    -MUTUAL EXCLUSION:  there are resources that cannot be shared
    -HOLD AND WAIT: A process is holding at least one resource and waiting for another resource which is with some other process.
    -NO PREEMPTION: The operating system is not allowed to take a resource back from a process until process gives it back
    -CIRCULAR WAIT:A set of processes are waiting for each other in circular form


DIFF B/W STARVATION & DEADLOCK
1	Deadlock is a situation where no process got blocked and no process proceeds :	Starvation is a situation where the low priority process got blocked and the high priority processes proceed.
2	Deadlock is an infinite waiting :	Starvation is a long waiting but not infinite.
3	Every Deadlock is always a starvation :	Every starvation need not be deadlock.
4	The requested resource is blocked by the other process :	The requested resource is continuously be used by the higher priority processes.
5	Deadlock happens when Mutual exclusion, hold and wait : No preemption and circular wait occurs simultaneously.	It occurs due to the uncontrolled priority and resource management

*********************************************

MEMORY MANAGEMENT














***********************************************
VIRTUAL MEMORY



**********************************************
THRASHING

BELADY'S ANOMALY




